{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///quick-pivot.min.js","webpack:///webpack/bootstrap 3930c9dfb1cdf8a7d86e","webpack:///./src/index.js","webpack:///./src/logic.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","fixDataFormat","data","Array","isArray","length","_typeof","reduce","dataCol","row","i","arr","push","acc","curr","index","groupByCategory","groupBy","category","groupByCategories","groups","arguments","undefined","filter","ele","groupCopy","assign","groupedData","shift","groupedDataKeys","keys","children","map","el","createColumnHeaders","cols","firstColumn","columnHeaders","mapToHeader","mapPos","columnHeaderRecursion","pos","headerMap","currKeys","reqLength","currLength","concat","fill","accumulator","accCat","accType","accValue","array","Number","checkPivotCategories","actualCats","selectedCats","errMessage","forEach","selectedCat","indexOf","Error","join","tableCreator","rowRecurse","rowGroups","_loop","recursedData","recurseThroughMap","dataPos","prevKey","datum","dataRows","accCatOrCB","accTypeOrInitVal","rawDataDatum","rawData","headerLength","innerKey","rows","rowHeader","columnData","table","Symbol","iterator","constructor","prototype"],"mappings":"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","file":"quick-pivot.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"quick-pivot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"quick-pivot\"] = factory();\n\telse\n\t\troot[\"quick-pivot\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"quick-pivot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"quick-pivot\"] = factory();\n\telse\n\t\troot[\"quick-pivot\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction fixDataFormat(data) {\n\t  if (!Array.isArray(data) || !data.length) return [];else if (_typeof(data[0]) === 'object' && !Array.isArray(data[0])) return data;\n\t  return data.reduce(function (dataCol, row, i, arr) {\n\t    if (i !== 0) {\n\t      if (Array.isArray(row)) {\n\t        dataCol.push(row.reduce(function (acc, curr, index) {\n\t          acc[arr[0][index]] = curr;\n\t          return acc;\n\t        }, {}));\n\t      } else {\n\t        dataCol.push(_defineProperty({}, arr[0], row));\n\t      }\n\t    }\n\t    return dataCol;\n\t  }, []);\n\t}\n\t\n\tfunction groupByCategory(data, groupBy) {\n\t  return data.reduce(function (acc, curr) {\n\t    var category = curr[groupBy];\n\t\n\t    if (!acc[category]) acc[category] = [];\n\t    acc[category].push(curr);\n\t    return acc;\n\t  }, {});\n\t}\n\t\n\tfunction groupByCategories(data) {\n\t  var groups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var acc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (!data.length) return [];\n\t\n\t  groups = groups.filter(function (ele) {\n\t    return ele in data[0];\n\t  });\n\t\n\t  if (!groups.length) return data;\n\t\n\t  var groupCopy = Object.assign([], groups);\n\t  var groupedData = groupByCategory(data, groupCopy.shift());\n\t  var groupedDataKeys = Object.keys(groupedData);\n\t  var children = groupedDataKeys.map(function (el) {\n\t    return groupedData[el];\n\t  });\n\t\n\t  for (var i = 0; i < children.length; i++) {\n\t    acc[groupedDataKeys[i]] = groupCopy.length ? {} : [];\n\t    acc[groupedDataKeys[i]] = groupByCategories(children[i], groupCopy, acc[groupedDataKeys[i]]);\n\t  }\n\t\n\t  return acc;\n\t}\n\t\n\tfunction createColumnHeaders(data) {\n\t  var cols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var firstColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t\n\t  if (!cols.length) return { columnHeaders: [firstColumn], mapToHeader: 1 };\n\t\n\t  var groupedData = groupByCategories(data, cols);\n\t  var columnHeaders = [];\n\t  var mapToHeader = Object.assign({}, groupedData);\n\t  var mapPos = 1;\n\t\n\t  (function columnHeaderRecursion(data) {\n\t    var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t    var headerMap = arguments[2];\n\t\n\t    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || Array.isArray(data)) return 1;\n\t\n\t    var currKeys = Object.keys(data);\n\t    var reqLength = 0;\n\t\n\t    for (var i = 0; i < currKeys.length; i++) {\n\t      var currLength = columnHeaderRecursion(data[currKeys[i]], pos + 1, headerMap[currKeys[i]]);\n\t\n\t      if (Array.isArray(data[currKeys[i]])) {\n\t        headerMap[currKeys[i]] = mapPos;\n\t        mapPos += 1;\n\t      }\n\t      reqLength += currLength;\n\t      columnHeaders[pos] = !columnHeaders[pos] ? [firstColumn].concat(Array(currLength).fill(currKeys[i])) : columnHeaders[pos].concat(Array(currLength).fill(currKeys[i]));\n\t    }\n\t    return reqLength;\n\t  })(groupedData, 0, mapToHeader);\n\t\n\t  return {\n\t    columnHeaders: columnHeaders,\n\t    mapToHeader: mapToHeader\n\t  };\n\t}\n\t\n\t/**\n\t * accumulator has two different signatures\n\t * 1. it takes an array of objects, an accumulation category as a string\n\t *  (like age), and supported accumulation type as a string (like count)\n\t * 2. it takes an array of objects, a callback function (which operates\n\t *  the same as reduce), and an initial value\n\t */\n\tfunction accumulator(arr, accCat, accType, accValue) {\n\t  if (!accCat && typeof accType !== 'function') accType = 'count';else if (typeof accCat === 'function') {\n\t    accValue = accType || 0;\n\t    accType = accCat;\n\t  }\n\t\n\t  return arr.reduce(function (acc, curr, index, array) {\n\t    if (typeof accType === 'function') {\n\t      return accType(acc, typeof accCat === 'string' ? curr[accCat] : curr, index, array);\n\t    }\n\t    switch (accType) {\n\t      case 'sum':\n\t        {\n\t          acc += Number(curr[accCat]);\n\t          return acc;\n\t        }\n\t\n\t      case 'count':\n\t        {\n\t          acc += 1;\n\t          return acc;\n\t        }\n\t\n\t      default:\n\t        {\n\t          acc += 1;\n\t          return acc;\n\t        }\n\t    }\n\t  }, accValue || 0);\n\t}\n\t\n\tfunction checkPivotCategories(actualCats, selectedCats) {\n\t  var errMessage = [];\n\t\n\t  selectedCats.forEach(function (selectedCat) {\n\t    if (actualCats.indexOf(selectedCat) === -1) errMessage.push(selectedCat);\n\t  });\n\t  if (errMessage.length) {\n\t    throw new Error('Check that these selected pivot categories exist: ' + errMessage.join(','));\n\t  }\n\t}\n\t\n\tfunction tableCreator(data) {\n\t  var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var cols = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t  var accCatOrCB = arguments[3];\n\t  var accTypeOrInitVal = arguments[4];\n\t  var rowHeader = arguments[5];\n\t\n\t  data = fixDataFormat(data);\n\t  if (!data.length) return [];\n\t  checkPivotCategories(Object.keys(data[0]), rows);\n\t  checkPivotCategories(Object.keys(data[0]), cols);\n\t\n\t  if (typeof rowHeader === 'undefined') {\n\t    rowHeader = typeof accCatOrCB !== 'function' ? accTypeOrInitVal + ' ' + accCatOrCB : 'Custom Agg';\n\t  }\n\t\n\t  var columnData = createColumnHeaders(data, cols, rowHeader);\n\t  var columnHeaders = Array.isArray(columnData.columnHeaders[0]) ? columnData.columnHeaders : [columnData.columnHeaders.concat(rowHeader)];\n\t  var mapToHeader = columnData.mapToHeader;\n\t  var headerLength = columnHeaders[0].length;\n\t\n\t  var dataRows = [];\n\t  var rawData = [];\n\t  var prevKey = '';\n\t\n\t  function rowRecurse(rowGroups) {\n\t    var _loop = function _loop(key) {\n\t      if (Array.isArray(rowGroups[key])) {\n\t        recursedData = groupByCategories(rowGroups[key], cols);\n\t\n\t\n\t        (function recurseThroughMap(dataPos, map) {\n\t          if (Array.isArray(dataPos)) {\n\t            if (key === prevKey) {\n\t              var datum = dataRows[dataRows.length - 1];\n\t\n\t              datum[map] = accumulator(dataPos, accCatOrCB, accTypeOrInitVal);\n\t              dataRows[dataRows.length - 1] = datum;\n\t\n\t              var rawDataDatum = rawData[rawData.length - 1];\n\t\n\t              rawDataDatum[map] = dataPos;\n\t              rawData[rawData.length - 1] = rawDataDatum;\n\t            } else {\n\t              prevKey = key;\n\t              var _datum = [key].concat(Array(map - 1).fill(''), accumulator(dataPos, accCatOrCB, accTypeOrInitVal), Array(headerLength - (map + 1)).fill(''));\n\t              var _rawDataDatum = [key].concat(Array(map - 1).fill(''), [dataPos], Array(headerLength - (map + 1)).fill(''));\n\t\n\t              rawData.push(_rawDataDatum);\n\t              dataRows.push(_datum);\n\t            }\n\t          } else {\n\t            for (var innerKey in dataPos) {\n\t              recurseThroughMap(dataPos[innerKey], map[innerKey]);\n\t            }\n\t          }\n\t        })(recursedData, mapToHeader || 1);\n\t      } else {\n\t        dataRows.push([key].concat(Array(headerLength - 1).fill('')));\n\t        rowRecurse(rowGroups[key], key);\n\t      }\n\t    };\n\t\n\t    for (var key in rowGroups) {\n\t      var recursedData;\n\t\n\t      _loop(key);\n\t    }\n\t  }\n\t\n\t  if (rows.length || cols.length) {\n\t    rowRecurse(groupByCategories(data, rows.length ? rows : cols));\n\t  } else {\n\t    dataRows.push([rowHeader, accumulator(data, accCatOrCB, accTypeOrInitVal)]);\n\t    rawData = data;\n\t  }\n\t\n\t  return {\n\t    table: columnHeaders.concat(dataRows),\n\t    rawData: rawData\n\t  };\n\t}\n\t\n\tmodule.exports = {\n\t  tableCreator: tableCreator,\n\t  fixDataFormat: fixDataFormat,\n\t  groupByCategory: groupByCategory,\n\t  groupByCategories: groupByCategories,\n\t  createColumnHeaders: createColumnHeaders,\n\t  accumulator: accumulator,\n\t  checkPivotCategories: checkPivotCategories\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** quick-pivot.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3930c9dfb1cdf8a7d86e\n **/","'use strict';\n\nmodule.exports = require('./logic.js');\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/index.js\n **/","'use strict';\n\nfunction fixDataFormat(data) {\n  if (!Array.isArray(data) || !data.length) return [];\n  else if (typeof data[0] === 'object' && !Array.isArray(data[0])) return data;\n  return data.reduce((dataCol, row, i, arr) => {\n    if (i !== 0) {\n      if (Array.isArray(row)) {\n        dataCol.push(row.reduce((acc, curr, index) =>{\n          acc[arr[0][index]] = curr;\n          return acc;\n        }, {}));\n      } else {\n        dataCol.push({[arr[0]]: row});\n      }\n    }\n    return dataCol;\n  }, []);\n}\n\nfunction groupByCategory(data, groupBy) {\n  return data.reduce((acc, curr) =>{\n    var category = curr[groupBy];\n\n    if (!acc[category]) acc[category] = [];\n    acc[category].push(curr);\n    return acc;\n  }, {});\n}\n\nfunction groupByCategories(data, groups = [], acc = {}) {\n  if (!data.length) return [];\n\n  groups = groups.filter(ele =>{\n    return ele in data[0];\n  });\n\n  if (!groups.length) return data;\n\n  var groupCopy = Object.assign([], groups);\n  var groupedData = groupByCategory(data, groupCopy.shift());\n  var groupedDataKeys = Object.keys(groupedData);\n  var children = groupedDataKeys.map(el => {\n    return groupedData[el];\n  });\n\n  for (let i = 0; i < children.length; i++) {\n    acc[groupedDataKeys[i]] = groupCopy.length ? {} : [];\n    acc[groupedDataKeys[i]] = groupByCategories(\n        children[i], groupCopy, acc[groupedDataKeys[i]]);\n  }\n\n  return acc;\n}\n\nfunction createColumnHeaders(data, cols = [], firstColumn = '') {\n  if (!cols.length) return {columnHeaders: [firstColumn], mapToHeader: 1};\n\n  var groupedData = groupByCategories(data, cols);\n  var columnHeaders = [];\n  var mapToHeader = Object.assign({}, groupedData);\n  var mapPos = 1;\n\n  (function columnHeaderRecursion(data, pos = 0, headerMap) {\n    if (typeof data !== 'object' || Array.isArray(data)) return 1;\n\n    var currKeys = Object.keys(data);\n    var reqLength = 0;\n\n    for (let i = 0; i < currKeys.length; i++) {\n      let currLength = columnHeaderRecursion(\n          data[currKeys[i]], pos + 1, headerMap[currKeys[i]]);\n\n      if (Array.isArray(data[currKeys[i]])) {\n        headerMap[currKeys[i]] = mapPos;\n        mapPos += 1;\n      }\n      reqLength += currLength;\n      columnHeaders[pos] = !columnHeaders[pos] ?\n          [firstColumn].concat(Array(currLength).fill(currKeys[i])) :\n          columnHeaders[pos].concat(Array(currLength).fill(currKeys[i]));\n    }\n    return reqLength;\n\n  })(groupedData, 0, mapToHeader);\n\n  return {\n    columnHeaders,\n    mapToHeader\n  };\n}\n\n/**\n * accumulator has two different signatures\n * 1. it takes an array of objects, an accumulation category as a string\n *  (like age), and supported accumulation type as a string (like count)\n * 2. it takes an array of objects, a callback function (which operates\n *  the same as reduce), and an initial value\n */\nfunction accumulator(arr, accCat, accType, accValue) {\n  if (!accCat && typeof accType !== 'function') accType = 'count';\n  else if (typeof accCat === 'function') {\n    accValue = accType || 0;\n    accType = accCat;\n  }\n\n  return arr.reduce((acc, curr, index, array) => {\n    if (typeof accType === 'function') {\n      return accType(acc, typeof accCat === 'string' ? curr[accCat] :\n                                                       curr, index, array);\n    }\n    switch (accType) {\n      case ('sum'): {\n        acc += Number(curr[accCat]);\n        return acc;\n      }\n\n      case ('count'): {\n        acc += 1;\n        return acc;\n      }\n\n      default: {\n        acc += 1;\n        return acc;\n      }\n    }\n  }, accValue || 0);\n}\n\nfunction checkPivotCategories(actualCats, selectedCats) {\n  var errMessage = [];\n\n  selectedCats.forEach(selectedCat =>{\n    if (actualCats.indexOf(selectedCat) === -1) errMessage.push(selectedCat);\n  });\n  if (errMessage.length) {\n    throw new Error(\n        `Check that these selected pivot categories exist: ${errMessage.join(\n            ',')}`);\n  }\n}\n\nfunction tableCreator(\n    data, rows = [], cols = [], accCatOrCB, accTypeOrInitVal, rowHeader) {\n  data = fixDataFormat(data);\n  if (!data.length) return [];\n  checkPivotCategories(Object.keys(data[0]), rows);\n  checkPivotCategories(Object.keys(data[0]), cols);\n\n  if (typeof rowHeader === 'undefined') {\n    rowHeader = typeof accCatOrCB !== 'function' ?\n        `${accTypeOrInitVal} ${accCatOrCB}` :\n        'Custom Agg';\n  }\n\n  const columnData = createColumnHeaders(data, cols, rowHeader);\n  const columnHeaders = Array.isArray(columnData.columnHeaders[0]) ?\n      columnData.columnHeaders :\n      [columnData.columnHeaders.concat(rowHeader)];\n  const mapToHeader = columnData.mapToHeader;\n  const headerLength = columnHeaders[0].length;\n\n  var dataRows = [];\n  var rawData = [];\n  var prevKey = '';\n\n  function rowRecurse(rowGroups) {\n    for (let key in rowGroups) {\n      if (Array.isArray(rowGroups[key])) {\n        var recursedData = groupByCategories(rowGroups[key], cols);\n\n        (function recurseThroughMap(dataPos, map) {\n          if (Array.isArray(dataPos)) {\n            if (key === prevKey) {\n              let datum = dataRows[dataRows.length - 1];\n\n              datum[map] = accumulator(dataPos, accCatOrCB, accTypeOrInitVal);\n              dataRows[dataRows.length - 1] = datum;\n\n              let rawDataDatum = rawData[rawData.length - 1];\n\n              rawDataDatum[map] = dataPos;\n              rawData[rawData.length - 1] = rawDataDatum;\n            } else {\n              prevKey = key;\n              let datum = [key].concat(\n                  Array(map - 1).fill(''),\n                  accumulator(dataPos, accCatOrCB, accTypeOrInitVal),\n                  Array(headerLength - (map + 1)).fill(''));\n              let rawDataDatum = [key].concat(\n                Array(map - 1).fill(''),\n                [dataPos],\n                Array(headerLength - (map + 1)).fill(''));\n\n              rawData.push(rawDataDatum);\n              dataRows.push(datum);\n            }\n          } else {\n            for (let innerKey in dataPos) {\n              recurseThroughMap(dataPos[innerKey], map[innerKey]);\n            }\n          }\n        })(recursedData, mapToHeader || 1);\n\n      } else {\n        dataRows.push([key].concat(Array(headerLength - 1).fill('')));\n        rowRecurse(rowGroups[key], key);\n      }\n    }\n  }\n\n  if (rows.length || cols.length) {\n    rowRecurse(groupByCategories(data, rows.length ? rows : cols));\n  } else {\n    dataRows.push([rowHeader, accumulator(data, accCatOrCB, accTypeOrInitVal)]);\n    rawData = data;\n  }\n\n  return {\n    table: columnHeaders.concat(dataRows),\n    rawData\n  };\n\n}\n\nmodule.exports = {\n  tableCreator,\n  fixDataFormat,\n  groupByCategory,\n  groupByCategories,\n  createColumnHeaders,\n  accumulator,\n  checkPivotCategories\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/logic.js\n **/"],"sourceRoot":""}