{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///quick-pivot.min.js","webpack:///webpack/bootstrap 03d64b298dce61b1ed49","webpack:///./src/index.js","webpack:///./src/logic.js","webpack:///./src/progressiveDiscovery.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_logic","_progressiveDiscovery","Pivot","data","rows","cols","agg","type","header","originalData","tableCreator","collapsedRows","rowNum","returnedData","collapse","table","row","collapsed","uncollapsed","expand","rawData","_defineProperty","obj","fixDataFormat","Array","isArray","_typeof","reduce","dataCol","arr","push","acc","curr","index","groupByCategory","groupBy","category","groupByCategories","groups","arguments","undefined","filter","ele","groupCopy","assign","groupedData","shift","groupedDataKeys","keys","children","map","el","createColumnHeaders","firstColumn","columnHeaders","mapToHeader","mapPos","columnHeaderRecursion","pos","headerMap","currKeys","reqLength","currLength","concat","fill","accumulator","accCat","accType","accValue","array","Number","checkPivotCategories","actualCats","selectedCats","errMessage","forEach","selectedCat","indexOf","Error","join","rowRecurse","rowGroups","depth","rowHeaders","_loop","recursedData","prevKey","recurseThroughMap","dataPos","datum","dataRows","accCatOrCB","accTypeOrInitVal","rawDataDatum","headerLength","formattedColumnHeaders","innerKey","rowHeaderValue","rowHeader","columnData","dataGroups","slice","Symbol","iterator","constructor","_toConsumableArray","arr2","from","selectedRow","count","currDepth","currData","_currData$table","_currData$rawData","splice","apply"],"mappings":"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","file":"quick-pivot.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"quick-pivot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"quick-pivot\"] = factory();\n\telse\n\t\troot[\"quick-pivot\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"quick-pivot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"quick-pivot\"] = factory();\n\telse\n\t\troot[\"quick-pivot\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _logic = __webpack_require__(1);\n\t\n\tvar _progressiveDiscovery = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Pivot = function () {\n\t  function Pivot(data, rows, cols, agg, type, header) {\n\t    _classCallCheck(this, Pivot);\n\t\n\t    if (!data) {\n\t      this.originalData = {};\n\t    } else {\n\t      this.originalData = (0, _logic.tableCreator)(data, rows, cols, agg, type, header);\n\t    }\n\t\n\t    this.data = this.originalData;\n\t    this.collapsedRows = {};\n\t  }\n\t\n\t  _createClass(Pivot, [{\n\t    key: 'update',\n\t    value: function update(data, rows, cols, agg, type, header) {\n\t      this.originalData = (0, _logic.tableCreator)(data, rows, cols, agg, type, header);\n\t      this.data = this.originalData;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'collapse',\n\t    value: function collapse(rowNum) {\n\t      var returnedData = (0, _progressiveDiscovery.collapse)(rowNum, this.data);\n\t\n\t      this.collapsedRows[this.data.table[rowNum].row] = returnedData.collapsed;\n\t      this.data = returnedData.uncollapsed;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'expand',\n\t    value: function expand(rowNum) {\n\t      this.data = (0, _progressiveDiscovery.expand)(rowNum, this.data, this.collapsedRows[this.data.table[rowNum].row]);\n\t      delete this.collapsedRows[this.data.table[rowNum].row];\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'getData',\n\t    value: function getData(rowNum) {\n\t      if (!this.data.table[rowNum]) return null;\n\t      if (this.collapsedRows[this.data.table[rowNum].row]) {\n\t        return this.collapsedRows[this.data.table[rowNum].row].rawData;\n\t      }\n\t\n\t      return this.originalData.rawData[this.data.table[rowNum].row];\n\t    }\n\t  }]);\n\t\n\t  return Pivot;\n\t}();\n\t\n\texports.default = Pivot;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.fixDataFormat = fixDataFormat;\n\texports.groupByCategory = groupByCategory;\n\texports.groupByCategories = groupByCategories;\n\texports.createColumnHeaders = createColumnHeaders;\n\texports.accumulator = accumulator;\n\texports.checkPivotCategories = checkPivotCategories;\n\texports.tableCreator = tableCreator;\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction fixDataFormat(data) {\n\t  if (!Array.isArray(data) || !data.length) return [];else if (_typeof(data[0]) === 'object' && !Array.isArray(data[0])) return data;\n\t  return data.reduce(function (dataCol, row, i, arr) {\n\t    if (i !== 0) {\n\t      if (Array.isArray(row)) {\n\t        dataCol.push(row.reduce(function (acc, curr, index) {\n\t          acc[arr[0][index]] = curr;\n\t          return acc;\n\t        }, {}));\n\t      } else {\n\t        dataCol.push(_defineProperty({}, arr[0], row));\n\t      }\n\t    }\n\t    return dataCol;\n\t  }, []);\n\t}\n\t\n\tfunction groupByCategory(data, groupBy) {\n\t  return data.reduce(function (acc, curr) {\n\t    var category = curr[groupBy];\n\t\n\t    if (!acc[category]) acc[category] = [];\n\t    acc[category].push(curr);\n\t    return acc;\n\t  }, {});\n\t}\n\t\n\tfunction groupByCategories(data) {\n\t  var groups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var acc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (!data.length) return [];\n\t\n\t  groups = groups.filter(function (ele) {\n\t    return ele in data[0];\n\t  });\n\t\n\t  if (!groups.length) return data;\n\t\n\t  var groupCopy = Object.assign([], groups);\n\t  var groupedData = groupByCategory(data, groupCopy.shift());\n\t  var groupedDataKeys = Object.keys(groupedData);\n\t  var children = groupedDataKeys.map(function (el) {\n\t    return groupedData[el];\n\t  });\n\t\n\t  for (var i = 0; i < children.length; i++) {\n\t    acc[groupedDataKeys[i]] = groupCopy.length ? {} : [];\n\t    acc[groupedDataKeys[i]] = groupByCategories(children[i], groupCopy, acc[groupedDataKeys[i]]);\n\t  }\n\t\n\t  return acc;\n\t}\n\t\n\tfunction createColumnHeaders(data) {\n\t  var cols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var firstColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t\n\t  if (!cols.length) return { columnHeaders: [firstColumn], mapToHeader: 1 };\n\t\n\t  var groupedData = groupByCategories(data, cols);\n\t  var columnHeaders = [];\n\t  var mapToHeader = Object.assign({}, groupedData);\n\t  var mapPos = 1;\n\t\n\t  (function columnHeaderRecursion(data) {\n\t    var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t    var headerMap = arguments[2];\n\t\n\t    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || Array.isArray(data)) return 1;\n\t\n\t    var currKeys = Object.keys(data);\n\t    var reqLength = 0;\n\t\n\t    for (var i = 0; i < currKeys.length; i++) {\n\t      var currLength = columnHeaderRecursion(data[currKeys[i]], pos + 1, headerMap[currKeys[i]]);\n\t\n\t      if (Array.isArray(data[currKeys[i]])) {\n\t        headerMap[currKeys[i]] = mapPos;\n\t        mapPos += 1;\n\t      }\n\t      reqLength += currLength;\n\t      columnHeaders[pos] = !columnHeaders[pos] ? [firstColumn].concat(Array(currLength).fill(currKeys[i])) : columnHeaders[pos].concat(Array(currLength).fill(currKeys[i]));\n\t    }\n\t    return reqLength;\n\t  })(groupedData, 0, mapToHeader);\n\t\n\t  return {\n\t    columnHeaders: columnHeaders,\n\t    mapToHeader: mapToHeader\n\t  };\n\t}\n\t\n\t/**\n\t * accumulator has two different signatures\n\t * 1. it takes an array of objects, an accumulation category as a string\n\t *  (like age), and supported accumulation type as a string (like count)\n\t * 2. it takes an array of objects, a callback function (which operates\n\t *  the same as reduce), and an initial value\n\t */\n\tfunction accumulator(arr, accCat, accType, accValue) {\n\t  if (!accCat && typeof accType !== 'function') accType = 'count';else if (typeof accCat === 'function') {\n\t    accValue = accType || 0;\n\t    accType = accCat;\n\t  }\n\t\n\t  return arr.reduce(function (acc, curr, index, array) {\n\t    if (typeof accType === 'function') {\n\t      return accType(acc, typeof accCat === 'string' ? curr[accCat] : curr, index, array);\n\t    }\n\t    switch (accType) {\n\t      case 'average':\n\t        {\n\t          acc += Number(curr[accCat]) / arr.length;\n\t          return acc;\n\t        }\n\t\n\t      case 'count':\n\t        {\n\t          acc += 1;\n\t          return acc;\n\t        }\n\t\n\t      case 'min':\n\t        {\n\t          if (index === 0) {\n\t            acc = Number(curr[accCat]);\n\t          } else if (curr[accCat] < acc) {\n\t            acc = Number(curr[accCat]);\n\t          }\n\t          return acc;\n\t        }\n\t\n\t      case 'max':\n\t        {\n\t          if (index === 0) {\n\t            acc = Number(curr[accCat]);\n\t          } else if (curr[accCat] > acc) {\n\t            acc = Number(curr[accCat]);\n\t          }\n\t          return acc;\n\t        }\n\t\n\t      case 'sum':\n\t        {\n\t          acc += Number(curr[accCat]);\n\t          return acc;\n\t        }\n\t\n\t      default:\n\t        {\n\t          acc += 1;\n\t          return acc;\n\t        }\n\t    }\n\t  }, accValue || 0);\n\t}\n\t\n\tfunction checkPivotCategories(actualCats, selectedCats) {\n\t  var errMessage = [];\n\t\n\t  selectedCats.forEach(function (selectedCat) {\n\t    if (actualCats.indexOf(selectedCat) === -1) errMessage.push(selectedCat);\n\t  });\n\t  if (errMessage.length) {\n\t    throw new Error('Check that these selected pivot categories exist: ' + errMessage.join(','));\n\t  }\n\t}\n\t\n\tfunction tableCreator(data) {\n\t  var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var cols = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t  var accCatOrCB = arguments[3];\n\t  var accTypeOrInitVal = arguments[4];\n\t  var rowHeader = arguments[5];\n\t\n\t  data = fixDataFormat(data);\n\t  if (!data.length) return [];\n\t  checkPivotCategories(Object.keys(data[0]), rows);\n\t  checkPivotCategories(Object.keys(data[0]), cols);\n\t\n\t  if (typeof rowHeader === 'undefined') {\n\t    rowHeader = typeof accCatOrCB !== 'function' ? accTypeOrInitVal + ' ' + accCatOrCB : 'Custom Agg';\n\t  }\n\t\n\t  var columnData = createColumnHeaders(data, cols, rowHeader);\n\t  var columnHeaders = Array.isArray(columnData.columnHeaders[0]) ? columnData.columnHeaders : [columnData.columnHeaders.concat(rowHeader)];\n\t  var mapToHeader = columnData.mapToHeader;\n\t  var headerLength = columnHeaders[0].length;\n\t  var formattedColumnHeaders = columnHeaders.map(function (value, depth) {\n\t    return {\n\t      value: value,\n\t      depth: depth,\n\t      type: 'colHeader',\n\t      row: depth\n\t    };\n\t  });\n\t\n\t  var dataRows = [];\n\t  var rawData = [];\n\t  var prevKey = '';\n\t\n\t  function rowRecurse(rowGroups, depth) {\n\t    var rowHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t    var _loop = function _loop(key) {\n\t      if (Array.isArray(rowGroups[key])) {\n\t        var recursedData = groupByCategories(rowGroups[key], cols);\n\t\n\t        prevKey = '';\n\t\n\t        (function recurseThroughMap(dataPos, map) {\n\t          if (Array.isArray(dataPos)) {\n\t            if (key === prevKey) {\n\t              var datum = dataRows[dataRows.length - 1].value;\n\t\n\t              datum[map] = accumulator(dataPos, accCatOrCB, accTypeOrInitVal);\n\t              dataRows[dataRows.length - 1].value = datum;\n\t\n\t              var rawDataDatum = rawData[rawData.length - 1].value;\n\t\n\t              rawDataDatum[map] = dataPos;\n\t              rawData[rawData.length - 1].value = rawDataDatum;\n\t            } else {\n\t              prevKey = key;\n\t              var _datum = [key].concat(Array(map - 1).fill(''), accumulator(dataPos, accCatOrCB, accTypeOrInitVal), Array(headerLength - (map + 1)).fill(''));\n\t              var _rawDataDatum = [key].concat(Array(map - 1).fill(''), [dataPos], Array(headerLength - (map + 1)).fill(''));\n\t\n\t              rawData.push({\n\t                value: _rawDataDatum,\n\t                type: 'data',\n\t                depth: depth\n\t              });\n\t              dataRows.push({\n\t                value: _datum,\n\t                type: 'data',\n\t                depth: depth,\n\t                row: dataRows.length + formattedColumnHeaders.length\n\t              });\n\t            }\n\t          } else {\n\t            for (var innerKey in dataPos) {\n\t              recurseThroughMap(dataPos[innerKey], map[innerKey]);\n\t            }\n\t          }\n\t        })(recursedData, mapToHeader || 1);\n\t      } else {\n\t        var rowHeaderValue = rowHeaders.shift();\n\t        var value = rowHeaderValue ? rowHeaderValue.value : [key].concat(Array(headerLength - 1).fill(''));\n\t\n\t        dataRows.push({\n\t          value: value,\n\t          depth: depth,\n\t          type: 'rowHeader',\n\t          row: dataRows.length + formattedColumnHeaders.length\n\t        });\n\t        rawData.push({\n\t          value: value,\n\t          depth: depth,\n\t          type: 'rowHeader'\n\t        });\n\t\n\t        rowRecurse(rowGroups[key], depth + 1, rowHeaders);\n\t      }\n\t    };\n\t\n\t    for (var key in rowGroups) {\n\t      _loop(key);\n\t    }\n\t  }\n\t\n\t  var dataGroups = [];\n\t\n\t  if (rows.length > 0) {\n\t    for (var i = 0; i < rows.length; i++) {\n\t      // possible memoization opportunity\n\t      rowRecurse(groupByCategories(data, rows.slice(0, i + 1)), 0, dataGroups);\n\t      dataGroups = Object.assign([], dataRows);\n\t      if (i + 1 < rows.length) {\n\t        dataRows = [];\n\t        rawData = [];\n\t        prevKey = '';\n\t      }\n\t    }\n\t  } else if (cols.length > 0) {\n\t    for (var _i = 0; _i < cols.length; _i++) {\n\t      rowRecurse(groupByCategories(data, cols.slice(0, _i + 1)), 0, dataGroups);\n\t      dataGroups = Object.assign([], dataRows);\n\t      if (_i + 1 < cols.length) {\n\t        dataRows = [];\n\t        rawData = [];\n\t        prevKey = '';\n\t      }\n\t    }\n\t  } else {\n\t    dataRows.push({\n\t      value: [rowHeader, accumulator(data, accCatOrCB, accTypeOrInitVal)],\n\t      type: 'data',\n\t      row: 1,\n\t      depth: 0\n\t    });\n\t    rawData = data.map(function (value) {\n\t      return {\n\t        value: value,\n\t        type: 0,\n\t        row: 1,\n\t        depth: 0\n\t      };\n\t    });\n\t  }\n\t\n\t  return {\n\t    table: formattedColumnHeaders.concat(dataRows),\n\t    rawData: formattedColumnHeaders.concat(rawData)\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.collapse = collapse;\n\texports.expand = expand;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction collapse(rowNum, data) {\n\t  var selectedRow = data.table[rowNum];\n\t  var type = selectedRow.type,\n\t      depth = selectedRow.depth;\n\t\n\t\n\t  if (type !== 'rowHeader' && type !== 'colHeader') {\n\t    return {\n\t      uncollapsed: data\n\t    };\n\t  }\n\t\n\t  var count = rowNum + 1;\n\t  var currDepth = data.table[count].depth;\n\t  var uncollapsed = {\n\t    table: data.table.slice(0, count),\n\t    rawData: data.rawData.slice(0, count)\n\t  };\n\t\n\t  var collapsed = {\n\t    table: [],\n\t    rawData: []\n\t  };\n\t\n\t  while (count < data.table.length && currDepth > depth) {\n\t    collapsed.rawData.push(data.rawData[count]);\n\t    collapsed.table.push(data.table[count]);\n\t    count += 1;\n\t    if (count < data.table.length) currDepth = data.table[count].depth;\n\t  }\n\t\n\t  uncollapsed.table = uncollapsed.table.concat(data.table.slice(count));\n\t  uncollapsed.rawData = uncollapsed.rawData.concat(data.rawData.slice(count));\n\t\n\t  return {\n\t    uncollapsed: uncollapsed,\n\t    collapsed: collapsed\n\t  };\n\t}\n\t\n\tfunction expand(rowNum, currData, collapsedRows) {\n\t  var _currData$table, _currData$rawData;\n\t\n\t  if (!collapsedRows) return currData;\n\t  (_currData$table = currData.table).splice.apply(_currData$table, [rowNum + 1, 0].concat(_toConsumableArray(collapsedRows.table)));\n\t  (_currData$rawData = currData.rawData).splice.apply(_currData$rawData, [rowNum + 1, 0].concat(_toConsumableArray(collapsedRows.rawData)));\n\t  return currData;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** quick-pivot.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 03d64b298dce61b1ed49\n **/","import { tableCreator } from './logic';\nimport { collapse, expand } from './progressiveDiscovery.js';\n\nexport default class Pivot {\n\n  constructor(data, rows, cols, agg, type, header) {\n    if (!data) {\n      this.originalData = {};\n    }else {\n      this.originalData = tableCreator(data, rows, cols, agg, type, header);\n    }\n\n    this.data = this.originalData;\n    this.collapsedRows = {};\n  }\n\n  update(data, rows, cols, agg, type, header) {\n    this.originalData = tableCreator(data, rows, cols, agg, type, header);\n    this.data = this.originalData;\n    return this;\n  }\n\n  collapse(rowNum) {\n    let returnedData = collapse(rowNum, this.data);\n\n    this.collapsedRows[this.data.table[rowNum].row] =\n        returnedData.collapsed;\n    this.data = returnedData.uncollapsed;\n    return this;\n  }\n\n  expand(rowNum) {\n    this.data = expand(\n      rowNum,\n      this.data,\n      this.collapsedRows[this.data.table[rowNum].row],\n    );\n    delete this.collapsedRows[this.data.table[rowNum].row];\n    return this;\n  }\n\n  getData(rowNum) {\n    if (!this.data.table[rowNum]) return null;\n    if (this.collapsedRows[this.data.table[rowNum].row]) {\n      return this.collapsedRows[this.data.table[rowNum].row].rawData;\n    }\n\n    return this.originalData.rawData[this.data.table[rowNum].row];\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/index.js\n **/","'use strict';\n\nexport function fixDataFormat(data) {\n  if (!Array.isArray(data) || !data.length) return [];\n  else if (typeof data[0] === 'object' && !Array.isArray(data[0])) return data;\n  return data.reduce((dataCol, row, i, arr) => {\n    if (i !== 0) {\n      if (Array.isArray(row)) {\n        dataCol.push(row.reduce((acc, curr, index) =>{\n          acc[arr[0][index]] = curr;\n          return acc;\n        }, {}));\n      } else {\n        dataCol.push({[arr[0]]: row});\n      }\n    }\n    return dataCol;\n  }, []);\n}\n\nexport function groupByCategory(data, groupBy) {\n  return data.reduce((acc, curr) =>{\n    var category = curr[groupBy];\n\n    if (!acc[category]) acc[category] = [];\n    acc[category].push(curr);\n    return acc;\n  }, {});\n}\n\nexport function groupByCategories(data, groups = [], acc = {}) {\n  if (!data.length) return [];\n\n  groups = groups.filter(ele =>{\n    return ele in data[0];\n  });\n\n  if (!groups.length) return data;\n\n  var groupCopy = Object.assign([], groups);\n  var groupedData = groupByCategory(data, groupCopy.shift());\n  var groupedDataKeys = Object.keys(groupedData);\n  var children = groupedDataKeys.map(el => {\n    return groupedData[el];\n  });\n\n  for (let i = 0; i < children.length; i++) {\n    acc[groupedDataKeys[i]] = groupCopy.length ? {} : [];\n    acc[groupedDataKeys[i]] = groupByCategories(\n        children[i], groupCopy, acc[groupedDataKeys[i]]);\n  }\n\n  return acc;\n}\n\nexport function createColumnHeaders(data, cols = [], firstColumn = '') {\n  if (!cols.length) return {columnHeaders: [firstColumn], mapToHeader: 1};\n\n  var groupedData = groupByCategories(data, cols);\n  var columnHeaders = [];\n  var mapToHeader = Object.assign({}, groupedData);\n  var mapPos = 1;\n\n  (function columnHeaderRecursion(data, pos = 0, headerMap) {\n    if (typeof data !== 'object' || Array.isArray(data)) return 1;\n\n    var currKeys = Object.keys(data);\n    var reqLength = 0;\n\n    for (let i = 0; i < currKeys.length; i++) {\n      let currLength = columnHeaderRecursion(\n          data[currKeys[i]], pos + 1, headerMap[currKeys[i]]);\n\n      if (Array.isArray(data[currKeys[i]])) {\n        headerMap[currKeys[i]] = mapPos;\n        mapPos += 1;\n      }\n      reqLength += currLength;\n      columnHeaders[pos] = !columnHeaders[pos] ?\n          [firstColumn].concat(Array(currLength).fill(currKeys[i])) :\n          columnHeaders[pos].concat(Array(currLength).fill(currKeys[i]));\n    }\n    return reqLength;\n\n  })(groupedData, 0, mapToHeader);\n\n  return {\n    columnHeaders,\n    mapToHeader,\n  };\n}\n\n/**\n * accumulator has two different signatures\n * 1. it takes an array of objects, an accumulation category as a string\n *  (like age), and supported accumulation type as a string (like count)\n * 2. it takes an array of objects, a callback function (which operates\n *  the same as reduce), and an initial value\n */\nexport function accumulator(arr, accCat, accType, accValue) {\n  if (!accCat && typeof accType !== 'function') accType = 'count';\n  else if (typeof accCat === 'function') {\n    accValue = accType || 0;\n    accType = accCat;\n  }\n\n  return arr.reduce((acc, curr, index, array) => {\n    if (typeof accType === 'function') {\n      return accType(acc, typeof accCat === 'string' ? curr[accCat] :\n        curr, index, array);\n    }\n    switch (accType) {\n      case ('average'): {\n        acc += Number(curr[accCat]) / arr.length;\n        return acc;\n      }\n\n      case ('count'): {\n        acc += 1;\n        return acc;\n      }\n\n      case ('min'): {\n        if (index === 0) {\n          acc = Number(curr[accCat]);\n        } else if (curr[accCat] < acc) {\n          acc = Number(curr[accCat]);\n        }\n        return acc;\n      }\n\n      case ('max'): {\n        if (index === 0) {\n          acc = Number(curr[accCat]);\n        } else if (curr[accCat] > acc) {\n          acc = Number(curr[accCat]);\n        }\n        return acc;\n      }\n\n      case ('sum'): {\n        acc += Number(curr[accCat]);\n        return acc;\n      }\n\n      default: {\n        acc += 1;\n        return acc;\n      }\n    }\n  }, accValue || 0);\n}\n\nexport function checkPivotCategories(actualCats, selectedCats) {\n  var errMessage = [];\n\n  selectedCats.forEach(selectedCat =>{\n    if (actualCats.indexOf(selectedCat) === -1) errMessage.push(selectedCat);\n  });\n  if (errMessage.length) {\n    throw new Error(\n        `Check that these selected pivot categories exist: ${errMessage.join(\n            ',')}`);\n  }\n}\n\nexport function tableCreator(\n  data, rows = [], cols = [], accCatOrCB, accTypeOrInitVal, rowHeader) {\n  data = fixDataFormat(data);\n  if (!data.length) return [];\n  checkPivotCategories(Object.keys(data[0]), rows);\n  checkPivotCategories(Object.keys(data[0]), cols);\n\n  if (typeof rowHeader === 'undefined') {\n    rowHeader = typeof accCatOrCB !== 'function' ?\n        `${accTypeOrInitVal} ${accCatOrCB}` :\n        'Custom Agg';\n  }\n\n  const columnData = createColumnHeaders(data, cols, rowHeader);\n  const columnHeaders = Array.isArray(columnData.columnHeaders[0]) ?\n      columnData.columnHeaders :\n      [columnData.columnHeaders.concat(rowHeader)];\n  const mapToHeader = columnData.mapToHeader;\n  const headerLength = columnHeaders[0].length;\n  const formattedColumnHeaders = columnHeaders.map((value, depth) => {\n    return {\n      value,\n      depth,\n      type: 'colHeader',\n      row: depth,\n    };\n  });\n\n  let dataRows = [];\n  let rawData = [];\n  let prevKey = '';\n\n  function rowRecurse(rowGroups, depth, rowHeaders = []) {\n    for (let key in rowGroups) {\n      if (Array.isArray(rowGroups[key])) {\n        const recursedData = groupByCategories(rowGroups[key], cols);\n\n        prevKey = '';\n\n        (function recurseThroughMap(dataPos, map) {\n          if (Array.isArray(dataPos)) {\n            if (key === prevKey) {\n              let datum = dataRows[dataRows.length - 1].value;\n\n              datum[map] = accumulator(dataPos, accCatOrCB, accTypeOrInitVal);\n              dataRows[dataRows.length - 1].value = datum;\n\n              let rawDataDatum = rawData[rawData.length - 1].value;\n\n              rawDataDatum[map] = dataPos;\n              rawData[rawData.length - 1].value = rawDataDatum;\n            } else {\n              prevKey = key;\n              let datum = [key].concat(\n                  Array(map - 1).fill(''),\n                  accumulator(dataPos, accCatOrCB, accTypeOrInitVal),\n                  Array(headerLength - (map + 1)).fill(''));\n              let rawDataDatum = [key].concat(\n                Array(map - 1).fill(''),\n                [dataPos],\n                Array(headerLength - (map + 1)).fill(''));\n\n              rawData.push({\n                value: rawDataDatum,\n                type: 'data',\n                depth,\n              });\n              dataRows.push({\n                value: datum,\n                type: 'data',\n                depth,\n                row: dataRows.length + formattedColumnHeaders.length,\n              });\n            }\n          } else {\n            for (let innerKey in dataPos) {\n              recurseThroughMap(dataPos[innerKey], map[innerKey]);\n            }\n          }\n        })(recursedData, mapToHeader || 1);\n\n      } else {\n        const rowHeaderValue = rowHeaders.shift();\n        const value = rowHeaderValue ?\n            rowHeaderValue.value :\n            [key].concat(Array(headerLength - 1).fill(''));\n\n        dataRows.push({\n          value,\n          depth,\n          type: 'rowHeader',\n          row: dataRows.length + formattedColumnHeaders.length,\n        });\n        rawData.push({\n          value,\n          depth,\n          type: 'rowHeader',\n        });\n\n        rowRecurse(rowGroups[key], depth + 1, rowHeaders);\n      }\n    }\n  }\n\n  let dataGroups = [];\n\n  if (rows.length > 0) {\n    for (let i = 0; i < rows.length; i++) {\n      // possible memoization opportunity\n      rowRecurse(groupByCategories(data, rows.slice(0, i + 1)), 0, dataGroups);\n      dataGroups = Object.assign([], dataRows);\n      if (i + 1 < rows.length) {\n        dataRows = [];\n        rawData = [];\n        prevKey = '';\n      }\n    }\n  } else if (cols.length > 0) {\n    for (let i = 0; i < cols.length; i++) {\n      rowRecurse(groupByCategories(data, cols.slice(0, i + 1)), 0, dataGroups);\n      dataGroups = Object.assign([], dataRows);\n      if (i + 1 < cols.length) {\n        dataRows = [];\n        rawData = [];\n        prevKey = '';\n      }\n    }\n  } else {\n    dataRows.push({\n      value: [rowHeader, accumulator(data, accCatOrCB, accTypeOrInitVal)],\n      type: 'data',\n      row: 1,\n      depth: 0,\n    });\n    rawData = data.map((value) => {\n      return {\n        value,\n        type: 0,\n        row: 1,\n        depth: 0,\n      };\n    });\n  }\n\n  return {\n    table: formattedColumnHeaders.concat(dataRows),\n    rawData: formattedColumnHeaders.concat(rawData),\n  };\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/logic.js\n **/","'use strict';\n\nexport function collapse(rowNum, data) {\n  const selectedRow = data.table[rowNum];\n  const {type, depth} = selectedRow;\n\n  if (type !== 'rowHeader' && type !== 'colHeader') {\n    return {\n      uncollapsed: data,\n    };\n  }\n\n  let count = rowNum + 1;\n  let currDepth = data.table[count].depth;\n  let uncollapsed = {\n    table: data.table.slice(0, count),\n    rawData: data.rawData.slice(0, count),\n  };\n\n  let collapsed = {\n    table: [],\n    rawData: [],\n  };\n\n  while (count < data.table.length && currDepth > depth) {\n    collapsed.rawData.push(data.rawData[count]);\n    collapsed.table.push(data.table[count]);\n    count += 1;\n    if (count < data.table.length) currDepth = data.table[count].depth;\n  }\n\n  uncollapsed.table = uncollapsed.table.concat(data.table.slice(count));\n  uncollapsed.rawData = uncollapsed.rawData.concat(data.rawData.slice(count));\n\n  return {\n    uncollapsed,\n    collapsed,\n  };\n}\n\nexport function expand(rowNum, currData, collapsedRows) {\n  if (!collapsedRows) return currData;\n  currData.table.splice(rowNum + 1, 0, ...collapsedRows.table);\n  currData.rawData.splice(rowNum + 1, 0, ...collapsedRows.rawData);\n  return currData;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/progressiveDiscovery.js\n **/"],"sourceRoot":""}